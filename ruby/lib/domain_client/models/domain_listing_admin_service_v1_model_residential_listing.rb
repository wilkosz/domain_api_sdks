=begin
#Domain Group API V1

#Provides public access to Domain's microservices

OpenAPI spec version: v1

Generated by: https://github.com/swagger-api/swagger-codegen.git
Swagger Codegen version: 2.4.9

=end

require 'date'

module DomainClient
  # Residential Listing
  class DomainListingAdminServiceV1ModelResidentialListing
    # Lifestyle type
    attr_accessor :life_style_type

    # Sale or Rent
    attr_accessor :listing_action

    # Indicates the listing preferred contact method. Default by both phone and email if not provided.
    attr_accessor :contact_preference

    # Set for Sale listings only
    attr_accessor :under_offer_or_contract

    # Optional, ignored for rental properties
    attr_accessor :auction

    # Optional.  Ignored for sale listings
    attr_accessor :bond

    # Optional. Sets the Date from which a Rental or Share property is available. Date format: yyyy-mm-dd
    attr_accessor :available_from

    # Residential property details, including property type, address, bedrooms etc
    attr_accessor :property_details

    # True if the property is a new development
    attr_accessor :is_new_development

    # Statement of Information,               required for sale listings in State of Victoria
    attr_accessor :statement_of_information

    # Fixed price or price range to be used for search, and free text display price
    attr_accessor :price

    # Domain Ad ID, not applicable for creating new ads.              Mandatory when updating a listing that belongs to an agency that              is in the process of being migrated between listing providers.
    attr_accessor :domain_ad_id

    # The Domain agency ID number
    attr_accessor :domain_agency_id

    # External ad ID up to 30 characters will be stored. This value is used to identify an ad for updates and should be unique for listing provider
    attr_accessor :provider_ad_id

    # Comma-separated list of features. 1000 characters in length. Select as appropriate or write your own.              INSIDE: Air conditioning, Ensuite, Floorboards, Indoor Spa, Gym, Alarm System, Intercom, Built in wardrobes, Furnished, Internal Laundry, Pets allowed, Cable or Satellite, Gas, Broadband internet access, Bath, Fireplace(s), Separate Dining Room, Heating, Dishwasher, Study.              OUTSIDE: Tennis Court, Secure Parking, Shed, Fully fenced, Balcony / Deck, Garden / Courtyard, Swimming Pool, Outdoor Spa.              LOCATION: Ground floor, Water Views, North Facing, City Views.              ECO FRIENDLY: Double glazed windows, Energy efficient appliances, Water efficient appliances, Wall / ceiling insulation, Rainwater storage tank, Greywater system, Water efficient fixtures, Solar hot water, Solar panels
    attr_accessor :features

    # Description of the property.              6000 characters in length. The following HTML elements are permitted: &amp;lt;br /&amp;gt;, &amp;lt;p&amp;gt;&amp;lt;/p&amp;gt;, &amp;amp;nbsp;. HTML must be well-formed.              Carriage Returns are interpreted as line breaks. Foreign characters must be HTML encoded, e.g., façade for façade
    attr_accessor :description

    # 'Headline' Any HTML stripped out.  If the Summary is less than 80 characters long then the description is concatenated to it and the total trimmed to 250 characters.
    attr_accessor :summary

    # The inspection details of the listing
    attr_accessor :inspection_details

    # Links to VideoURL, virtual tour or weblink. Maximum length of media URLs is 255 characters.
    attr_accessor :media

    # Minimum required attributes: First name, last name and E-mail.              If the DomainAgentId is provided, contact information will be based on the existing agent found for that id.              Otherwise first name, last name and email will be used to find the matching contact. A new contact will be created if no contact can be found.
    attr_accessor :contacts

    # Sets an additional Email Address to which enquiries on the Listing will be sent
    attr_accessor :other_enquiry_email

    # Send email enquiries to the default address for this listing type
    attr_accessor :receive_emails_to_default_address

    # True if the property is rural
    attr_accessor :is_rural

    # Rural attributes                            *Improvements* (optional)                            Available `types` (fixed list, optional):              * Machinery Shed              * Shearing Shed              * Workshop              * Shearers Quarters              * Silos              * Other Housing              * Managers Accommodation                            *Fencing* (optional)                            `description` (string, optional): free text fencing description, maximum 250 characters.                            *Yards* (optional)                            Available `types` (fixed list, optional):              * Sheep              * Cattle                            *Homestead* (optional)                            `description` (string, optional): description of the homestead and construction, maximum 250 characters.                            `metadata` (optional)              * `area` (decimal, optional): homestead area in square metres.                            Available `types` (fixed list, optional):              * Office              * Ensuite              * Tennis Court              * Mains Gas              * Floorboards              * Internal Laundry                            *Water* (optional)                            `description` (string, optional): water comments, maximum 250 characters.                            Available `types` (fixed list, optional):              * Tank              * Well              * Reticulated              * Bores              * Springs              * Creeks              * Dams              * River                            *Crops* (optional)                            `description` (string, optional): description of the crops, maximum 250 characters.                            `metadata` (optional)              * `croppedAnnually` (decimal, optional): average annual area cropped in hectares.              * `fallowAnnually` (decimal, optional): average annual fallow area in hectares.              * `pastures` (string, optional): description of pastures available, maximum 250 characters.                            *Livestock* (optional)                            `description` (string, optional): additional comments, maximum 250 characters.                            `metadata` (optional)              * `capacity` (decimal, optional): property carrying capacity in DSE (unit of carry capacity).                            Available `types` (fixed list, optional):              * Sheep              * Pigs              * Cattle              * Poultry              * Horses              * Exotic              * Goats              * Stud                            *Inclusions* (optional)                            `description` (string, optional): description of plant and machinery included in sale, maximum 250 characters.                            `metadata` (optional)              * `livestock` (string, optional): description of livestock included in sale, maximum 250 characters.              * `crop` (string, optional): description of crops included in sale, maximum 250 characters.                            *Irrigation* (optional)                            `description` (string, optional): irrigation comments, maximum 250 characters                            `metadata` (optional)              * `rainfall` (decimal, optional): annual rainfall in millimeters.
    attr_accessor :supplementary

    class EnumAttributeValidator
      attr_reader :datatype
      attr_reader :allowable_values

      def initialize(datatype, allowable_values)
        @allowable_values = allowable_values.map do |value|
          case datatype.to_s
          when /Integer/i
            value.to_i
          when /Float/i
            value.to_f
          else
            value
          end
        end
      end

      def valid?(value)
        !value || allowable_values.include?(value)
      end
    end

    # Attribute mapping from ruby-style variable name to JSON key.
    def self.attribute_map
      {
        :'life_style_type' => :'lifeStyleType',
        :'listing_action' => :'listingAction',
        :'contact_preference' => :'contactPreference',
        :'under_offer_or_contract' => :'underOfferOrContract',
        :'auction' => :'auction',
        :'bond' => :'bond',
        :'available_from' => :'availableFrom',
        :'property_details' => :'propertyDetails',
        :'is_new_development' => :'isNewDevelopment',
        :'statement_of_information' => :'statementOfInformation',
        :'price' => :'price',
        :'domain_ad_id' => :'domainAdId',
        :'domain_agency_id' => :'domainAgencyID',
        :'provider_ad_id' => :'providerAdId',
        :'features' => :'features',
        :'description' => :'description',
        :'summary' => :'summary',
        :'inspection_details' => :'inspectionDetails',
        :'media' => :'media',
        :'contacts' => :'contacts',
        :'other_enquiry_email' => :'otherEnquiryEmail',
        :'receive_emails_to_default_address' => :'receiveEmailsToDefaultAddress',
        :'is_rural' => :'isRural',
        :'supplementary' => :'supplementary'
      }
    end

    # Attribute type mapping.
    def self.swagger_types
      {
        :'life_style_type' => :'String',
        :'listing_action' => :'String',
        :'contact_preference' => :'String',
        :'under_offer_or_contract' => :'BOOLEAN',
        :'auction' => :'DomainListingAdminServiceV1ModelAuction',
        :'bond' => :'Integer',
        :'available_from' => :'DateTime',
        :'property_details' => :'DomainListingAdminServiceV1ModelResidentialProperty',
        :'is_new_development' => :'BOOLEAN',
        :'statement_of_information' => :'DomainListingAdminServiceV1ModelStatementOfInformation',
        :'price' => :'DomainListingAdminServiceV1ModelPrice',
        :'domain_ad_id' => :'Integer',
        :'domain_agency_id' => :'Integer',
        :'provider_ad_id' => :'String',
        :'features' => :'String',
        :'description' => :'String',
        :'summary' => :'String',
        :'inspection_details' => :'DomainListingAdminServiceV1ModelInspectionDetails',
        :'media' => :'Array<DomainListingAdminServiceV1ModelPropertyMedia>',
        :'contacts' => :'Array<DomainListingAdminServiceV1ModelContact>',
        :'other_enquiry_email' => :'String',
        :'receive_emails_to_default_address' => :'BOOLEAN',
        :'is_rural' => :'BOOLEAN',
        :'supplementary' => :'Array<DomainListingAdminServiceV1ModelListingSupplementary>'
      }
    end

    # Initializes the object
    # @param [Hash] attributes Model attributes in the form of hash
    def initialize(attributes = {})
      return unless attributes.is_a?(Hash)

      # convert string to symbol for hash key
      attributes = attributes.each_with_object({}) { |(k, v), h| h[k.to_sym] = v }

      if attributes.has_key?(:'lifeStyleType')
        self.life_style_type = attributes[:'lifeStyleType']
      end

      if attributes.has_key?(:'listingAction')
        self.listing_action = attributes[:'listingAction']
      end

      if attributes.has_key?(:'contactPreference')
        self.contact_preference = attributes[:'contactPreference']
      end

      if attributes.has_key?(:'underOfferOrContract')
        self.under_offer_or_contract = attributes[:'underOfferOrContract']
      end

      if attributes.has_key?(:'auction')
        self.auction = attributes[:'auction']
      end

      if attributes.has_key?(:'bond')
        self.bond = attributes[:'bond']
      end

      if attributes.has_key?(:'availableFrom')
        self.available_from = attributes[:'availableFrom']
      end

      if attributes.has_key?(:'propertyDetails')
        self.property_details = attributes[:'propertyDetails']
      end

      if attributes.has_key?(:'isNewDevelopment')
        self.is_new_development = attributes[:'isNewDevelopment']
      end

      if attributes.has_key?(:'statementOfInformation')
        self.statement_of_information = attributes[:'statementOfInformation']
      end

      if attributes.has_key?(:'price')
        self.price = attributes[:'price']
      end

      if attributes.has_key?(:'domainAdId')
        self.domain_ad_id = attributes[:'domainAdId']
      end

      if attributes.has_key?(:'domainAgencyID')
        self.domain_agency_id = attributes[:'domainAgencyID']
      end

      if attributes.has_key?(:'providerAdId')
        self.provider_ad_id = attributes[:'providerAdId']
      end

      if attributes.has_key?(:'features')
        self.features = attributes[:'features']
      end

      if attributes.has_key?(:'description')
        self.description = attributes[:'description']
      end

      if attributes.has_key?(:'summary')
        self.summary = attributes[:'summary']
      end

      if attributes.has_key?(:'inspectionDetails')
        self.inspection_details = attributes[:'inspectionDetails']
      end

      if attributes.has_key?(:'media')
        if (value = attributes[:'media']).is_a?(Array)
          self.media = value
        end
      end

      if attributes.has_key?(:'contacts')
        if (value = attributes[:'contacts']).is_a?(Array)
          self.contacts = value
        end
      end

      if attributes.has_key?(:'otherEnquiryEmail')
        self.other_enquiry_email = attributes[:'otherEnquiryEmail']
      end

      if attributes.has_key?(:'receiveEmailsToDefaultAddress')
        self.receive_emails_to_default_address = attributes[:'receiveEmailsToDefaultAddress']
      end

      if attributes.has_key?(:'isRural')
        self.is_rural = attributes[:'isRural']
      end

      if attributes.has_key?(:'supplementary')
        if (value = attributes[:'supplementary']).is_a?(Array)
          self.supplementary = value
        end
      end
    end

    # Show invalid properties with the reasons. Usually used together with valid?
    # @return Array for valid properties with the reasons
    def list_invalid_properties
      invalid_properties = Array.new
      invalid_properties
    end

    # Check to see if the all the properties in the model are valid
    # @return true if the model is valid
    def valid?
      life_style_type_validator = EnumAttributeValidator.new('String', ['firstHome', 'investment', 'retirement', 'seaChange', 'treeChange', 'youngFamilies'])
      return false unless life_style_type_validator.valid?(@life_style_type)
      listing_action_validator = EnumAttributeValidator.new('String', ['sale', 'rent', 'share', 'saleAndLease'])
      return false unless listing_action_validator.valid?(@listing_action)
      contact_preference_validator = EnumAttributeValidator.new('String', ['byPhone'])
      return false unless contact_preference_validator.valid?(@contact_preference)
      true
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] life_style_type Object to be assigned
    def life_style_type=(life_style_type)
      validator = EnumAttributeValidator.new('String', ['firstHome', 'investment', 'retirement', 'seaChange', 'treeChange', 'youngFamilies'])
      unless validator.valid?(life_style_type)
        fail ArgumentError, 'invalid value for "life_style_type", must be one of #{validator.allowable_values}.'
      end
      @life_style_type = life_style_type
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] listing_action Object to be assigned
    def listing_action=(listing_action)
      validator = EnumAttributeValidator.new('String', ['sale', 'rent', 'share', 'saleAndLease'])
      unless validator.valid?(listing_action)
        fail ArgumentError, 'invalid value for "listing_action", must be one of #{validator.allowable_values}.'
      end
      @listing_action = listing_action
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] contact_preference Object to be assigned
    def contact_preference=(contact_preference)
      validator = EnumAttributeValidator.new('String', ['byPhone'])
      unless validator.valid?(contact_preference)
        fail ArgumentError, 'invalid value for "contact_preference", must be one of #{validator.allowable_values}.'
      end
      @contact_preference = contact_preference
    end

    # Checks equality by comparing each attribute.
    # @param [Object] Object to be compared
    def ==(o)
      return true if self.equal?(o)
      self.class == o.class &&
          life_style_type == o.life_style_type &&
          listing_action == o.listing_action &&
          contact_preference == o.contact_preference &&
          under_offer_or_contract == o.under_offer_or_contract &&
          auction == o.auction &&
          bond == o.bond &&
          available_from == o.available_from &&
          property_details == o.property_details &&
          is_new_development == o.is_new_development &&
          statement_of_information == o.statement_of_information &&
          price == o.price &&
          domain_ad_id == o.domain_ad_id &&
          domain_agency_id == o.domain_agency_id &&
          provider_ad_id == o.provider_ad_id &&
          features == o.features &&
          description == o.description &&
          summary == o.summary &&
          inspection_details == o.inspection_details &&
          media == o.media &&
          contacts == o.contacts &&
          other_enquiry_email == o.other_enquiry_email &&
          receive_emails_to_default_address == o.receive_emails_to_default_address &&
          is_rural == o.is_rural &&
          supplementary == o.supplementary
    end

    # @see the `==` method
    # @param [Object] Object to be compared
    def eql?(o)
      self == o
    end

    # Calculates hash code according to all attributes.
    # @return [Fixnum] Hash code
    def hash
      [life_style_type, listing_action, contact_preference, under_offer_or_contract, auction, bond, available_from, property_details, is_new_development, statement_of_information, price, domain_ad_id, domain_agency_id, provider_ad_id, features, description, summary, inspection_details, media, contacts, other_enquiry_email, receive_emails_to_default_address, is_rural, supplementary].hash
    end

    # Builds the object from hash
    # @param [Hash] attributes Model attributes in the form of hash
    # @return [Object] Returns the model itself
    def build_from_hash(attributes)
      return nil unless attributes.is_a?(Hash)
      self.class.swagger_types.each_pair do |key, type|
        if type =~ /\AArray<(.*)>/i
          # check to ensure the input is an array given that the the attribute
          # is documented as an array but the input is not
          if attributes[self.class.attribute_map[key]].is_a?(Array)
            self.send("#{key}=", attributes[self.class.attribute_map[key]].map { |v| _deserialize($1, v) })
          end
        elsif !attributes[self.class.attribute_map[key]].nil?
          self.send("#{key}=", _deserialize(type, attributes[self.class.attribute_map[key]]))
        end # or else data not found in attributes(hash), not an issue as the data can be optional
      end

      self
    end

    # Deserializes the data based on type
    # @param string type Data type
    # @param string value Value to be deserialized
    # @return [Object] Deserialized data
    def _deserialize(type, value)
      case type.to_sym
      when :DateTime
        DateTime.parse(value)
      when :Date
        Date.parse(value)
      when :String
        value.to_s
      when :Integer
        value.to_i
      when :Float
        value.to_f
      when :BOOLEAN
        if value.to_s =~ /\A(true|t|yes|y|1)\z/i
          true
        else
          false
        end
      when :Object
        # generic object (usually a Hash), return directly
        value
      when /\AArray<(?<inner_type>.+)>\z/
        inner_type = Regexp.last_match[:inner_type]
        value.map { |v| _deserialize(inner_type, v) }
      when /\AHash<(?<k_type>.+?), (?<v_type>.+)>\z/
        k_type = Regexp.last_match[:k_type]
        v_type = Regexp.last_match[:v_type]
        {}.tap do |hash|
          value.each do |k, v|
            hash[_deserialize(k_type, k)] = _deserialize(v_type, v)
          end
        end
      else # model
        temp_model = DomainClient.const_get(type).new
        temp_model.build_from_hash(value)
      end
    end

    # Returns the string representation of the object
    # @return [String] String presentation of the object
    def to_s
      to_hash.to_s
    end

    # to_body is an alias to to_hash (backward compatibility)
    # @return [Hash] Returns the object in the form of hash
    def to_body
      to_hash
    end

    # Returns the object in the form of hash
    # @return [Hash] Returns the object in the form of hash
    def to_hash
      hash = {}
      self.class.attribute_map.each_pair do |attr, param|
        value = self.send(attr)
        next if value.nil?
        hash[param] = _to_hash(value)
      end
      hash
    end

    # Outputs non-array value in the form of hash
    # For object, use to_hash. Otherwise, just return the value
    # @param [Object] value Any valid value
    # @return [Hash] Returns the value in the form of hash
    def _to_hash(value)
      if value.is_a?(Array)
        value.compact.map { |v| _to_hash(v) }
      elsif value.is_a?(Hash)
        {}.tap do |hash|
          value.each { |k, v| hash[k] = _to_hash(v) }
        end
      elsif value.respond_to? :to_hash
        value.to_hash
      else
        value
      end
    end
  end
end
